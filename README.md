
# MPI & OpenMP Task Automation

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

_Important note: This project is in early development, so features are sparse and bugs may arise._

## **The Suite**

[ui.sh](ui.sh) offers some basic user interface.

[setup.sh](setup.sh) defines some aliases, set's up the console prompt and loads mpiP and OpenMP when sourced. You really only need loading mpiP and OpenMP. Everything else is entirely optional.

```bash
. ./setup.sh
```

[compile.sh](compile.sh) is responsible for compiling the MPI, OpenMP or Hybrid supplied source file into an executable.

It is expecting at least one arguement, the source file. Any other arguements are grouped and form pairs of keys and values, corresponding to a macro named **key** with a value of **value**.

Executing it with the --clean option deletes the executable.

```bash
./compile.sh mpi_trap1.c nTraps 512
[compile.sh] enable profiling: y
[compile.sh] link OpenMP: n
```

[schedule.sh](schedule.sh) is responsible for generating a job and submitting it to the PBS queue.

It is expecting exactly two arguements, the executable file and the number of processes to be created.

Executing it with the --clean option removes any mpiP associated file, any job file generated by it and removes any user associated job from the queue.

```bash
./schedule.sh mpi_trap1.x 16

[schedule.sh] name='mpi_trap1_16_argo059_job', id='14524.argo', ps=16, ns=2, ppn=8

Job id            Name             User              Time Use S Queue
----------------  ---------------- ----------------  -------- - -----
12507.argo        myJob            argo081                  0 Q workq
14524.argo        mpi_trap1_16_ar  argo059           00:00:00 R workq
```

[profile.sh](profile.sh) is responsible for compiling our program with different (key, value) macro pairs, running it with different number of processes and collecting our measurements.

It is expecting exactly two arguements, the source file and a [test script](#testing).

```bash
echo -e "y\nn\ny\nn\ny\nn\ny\nn\ny\nn\n" | ./profile.sh ./mpi_trap1.c ./test.sh

head ./out/20_11_2019/23_47_53/results.csv

nTraps   , Processes, Time    , Speed Up       , Î•fficiency
1048576  , 1        , 0.000827, 1.0            , 1.0
1048576  , 2        , 0.000982, 0.84215885947  , 0.421079429735
```

## **Configuration**

[config.sh](config.sh) contains some configuration settings and is being sourced into other files.

Let's see what configuration settings exist.

* **COMPILER** contains the name of the script being used to compile the source file.
* **SCHEDULER** contains the name of the script being used to schedule the executable for running.
* **OUTPUT_ROOT** indicates the root directory, which by default is **out**. Our scheduling and profiling script create some files and directories. These files and directories are going to have as a parent directory the root directory.
* **USER_ID** is being used when querying the job queue and its default value is the current user's username.
* **TIME_PATTERN** is a regular expression indicating the format of our timer's output.
* **EDITOR** and **EDITOR_ARGS** are optional configuration options. They are accessed when attempting to open a file for examination in the case of an error.

## **Testing**

Our profiler receives a test script. This test script must define:

* a variable name **MACRO**, which specifies the name of the macro to be defined when running our profiler.
* an array named **VALUES**, which contains the values the macro should receive at compilation.

So we can simply define a test in the following manner and the profiler is going to take care of everything else.

```bash
#!/bin/bash

MACRO="nTraps"

VALUES=()

for ((power = 20; power <= 28; power += 2))
do
    VALUES+=( "$(( 2 << ($power - 1) ))" )
done
```

